name: Build & Publish Docker Image

on:
  push:
    branches: ["main"]
    tags: ["v*"]
    paths-ignore:
      - '**.md'
      - 'docs/**'
  workflow_dispatch: {}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ghcr.io/idanbot/tele-home-supervisor

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: requirements.txt

      - name: Install Dependencies
        run: |
          pip install pylint black pip-audit bandit -r requirements.txt

      - name: Run Black (check)
        run: |
          set -o pipefail
          black --check . 2>&1 | tee black.log
          exit ${PIPESTATUS[0]:-0}

      - name: Run Pylint
        run: |
          set -o pipefail
          pylint --disable=all --enable=F,E tele_home_supervisor/ bot.py \
            2>&1 | tee pylint.log
          exit ${PIPESTATUS[0]:-0}

      - name: Run pip-audit
        run: |
          set -o pipefail
          pip-audit -r requirements.txt --progress-spinner off \
            2>&1 | tee pip-audit.log
          exit ${PIPESTATUS[0]:-0}

      - name: Run Bandit
        run: |
          set -o pipefail
          bandit -r tele_home_supervisor \
            2>&1 | tee bandit.log
          exit ${PIPESTATUS[0]:-0}

      - name: Notify Telegram (lint failure)
        if: failure()
        env:
          STATUS: ${{ job.status }}
          REF_TYPE: ${{ github.ref_type }}
          REF_NAME: ${{ github.ref_name }}
          SHA: ${{ github.sha }}
        run: |
          ICON="âŒ"; TEXT="Lint Failed"
          if [ "$REF_TYPE" = "tag" ]; then
            VERSION="$REF_NAME"
          else
            VERSION=$(echo "$SHA" | cut -c1-7)
          fi

          # Build a brief failure summary from available logs (tail 40 lines)
          SUMMARY=""
          if [ -f black.log ]; then
            SUMMARY+=$'\n<b>Black</b> (tail):\n<pre>'
            tail -n 40 black.log | sed 's/&/\&amp;/g;s/</\&lt;/g;s/>/\&gt;/g'
            SUMMARY+=$'</pre>'
          fi > lint_snippet.html
          if [ -f pylint.log ]; then
            {
              echo "<b>Pylint</b> (tail):<pre>" ;
              tail -n 40 pylint.log | sed 's/&/\&amp;/g;s/</\&lt;/g;s/>/\&gt;/g' ;
              echo "</pre>" ;
            } >> lint_snippet.html
          fi
          if [ -f pip-audit.log ]; then
            {
              echo "<b>pip-audit</b> (tail):<pre>" ;
              tail -n 40 pip-audit.log | sed 's/&/\&amp;/g;s/</\&lt;/g;s/>/\&gt;/g' ;
              echo "</pre>" ;
            } >> lint_snippet.html
          fi

          if [ -f bandit.log ]; then
            {
              echo "<b>Bandit</b> (tail):<pre>" ;
              tail -n 40 bandit.log | sed 's/&/\&amp;/g;s/</\&lt;/g;s/>/\&gt;/g' ;
              echo "</pre>" ;
            } >> lint_snippet.html
          fi

          SNIPPET=$(cat lint_snippet.html)

          MSG="<b>$ICON $TEXT</b>
          â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
          ğŸ“¦ <b>Repo:</b> <code>${{ github.repository }}</code>
          ğŸŒ¿ <b>Branch:</b> <code>$REF_NAME</code>
          ğŸ”— <b>Commit:</b> <code>$VERSION</code>
          â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
          $SNIPPET
          â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
          <a href='https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}'>ğŸ” View Logs</a>"

          jq -n \
            --arg chat_id "${{ secrets.TELEGRAM_CHAT_ID }}" \
            --arg parse_mode "HTML" \
            --arg text "$MSG" \
            '{chat_id:$chat_id, parse_mode:$parse_mode, disable_web_page_preview:true, text:$text}' \
            | curl -sf -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
                -H "Content-Type: application/json" \
                -d @-

  build-and-push:
    needs: [lint]
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: read
      packages: write
      security-events: write

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
            type=sha,prefix={{branch}}-
            type=ref,event=tag
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Compute Build Version
        id: buildver
        run: |
          TS="$(date -u +'%Y.%m.%d-%H:%M:%S')"
          echo "version=${TS}-r${GITHUB_RUN_NUMBER}" >> "$GITHUB_OUTPUT"

      # Single build step - ARM64 primary, AMD64 optional
      - name: Build and Push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          # ARM64 first (your primary target), AMD64 optional
          platforms: linux/arm64,linux/amd64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            BUILD_VERSION=${{ steps.buildver.outputs.version }}
          # Dual caching: GHA + Registry
          cache-from: |
            type=gha
            type=registry,ref=${{ env.IMAGE_NAME }}:buildcache
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ env.IMAGE_NAME }}:buildcache,mode=max

      # Scan ARM64 (primary target) after push
      - name: Scan ARM64 Image
        run: |
          # Pull ARM64 variant
          docker pull --platform linux/arm64 ${{ env.IMAGE_NAME }}:latest
          
          # Scan with Trivy
          docker run --rm \
            -v /var/run/docker.sock:/var/run/docker.sock \
            -v "$PWD:/workspace" \
            aquasec/trivy:latest image \
            --platform linux/arm64 \
            --severity HIGH,CRITICAL \
            --exit-code 0 \
            --format table \
            --output /workspace/trivy-arm64.txt \
            ${{ env.IMAGE_NAME }}:latest

      - name: Upload Trivy Scan (ARM64)
        uses: actions/upload-artifact@v4
        with:
          name: trivy-arm64
          path: trivy-arm64.txt
          if-no-files-found: error
          retention-days: 7

      - name: Notify Telegram
        if: always()
        env:
          STATUS: ${{ job.status }}
          REF_TYPE: ${{ github.ref_type }}
          REF_NAME: ${{ github.ref_name }}
          SHA: ${{ github.sha }}
          BUILD_VERSION: ${{ steps.buildver.outputs.version }}
        run: |
          # Status Icon
          case "$STATUS" in
            success) ICON="âœ…"; TEXT="Build Success" ;;
            failure) ICON="âŒ"; TEXT="Build Failed" ;;
            *)       ICON="âš ï¸"; TEXT="Cancelled" ;;
          esac

          # Version identifier
          if [ "$REF_TYPE" == "tag" ]; then
            VERSION="$REF_NAME"
          else
            VERSION=$(echo "$SHA" | cut -c1-7)
          fi

          MSG="<b>$ICON $TEXT</b>
          â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
          ğŸ“¦ <b>Repo:</b> <code>${{ github.repository }}</code>
          ğŸŒ¿ <b>Branch:</b> <code>$REF_NAME</code>
          ğŸ”— <b>Commit:</b> <code>$VERSION</code>
          ğŸ—ï¸ <b>Build:</b> <code>$BUILD_VERSION</code>
          ğŸ‘¤ <b>Author:</b> ${{ github.actor }}
          â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
          <a href='https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}'>ğŸ” View Logs</a>"

          # Send notification via jq to ensure valid JSON and avoid long lines
          jq -n \
            --arg chat_id "${{ secrets.TELEGRAM_CHAT_ID }}" \
            --arg parse_mode "HTML" \
            --arg text "$MSG" \
            '{chat_id:$chat_id, parse_mode:$parse_mode, disable_web_page_preview:true, text:$text}' \
            | curl -sf -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
                -H "Content-Type: application/json" \
                -d @-
